{"version":3,"sources":["../../node_modules/@fluent/sequence/esm/map_sync.js","../../node_modules/@fluent/sequence/esm/map_async.js","../../node_modules/@fluent/sequence/esm/index.js","../../node_modules/cached-iterable/src/cached_iterable.mjs","../../node_modules/cached-iterable/src/cached_sync_iterable.mjs","../../node_modules/cached-iterable/src/cached_async_iterable.mjs","../../node_modules/cached-iterable/src/index.mjs","../../src/index.js"],"names":["mapBundleSync","bundles","ids","Array","isArray","map","id","getBundleForId","bundle","hasMessage","mapBundleAsync","foundBundles","length","fill","remainingCount","index","entries","CachedIterable","from","iterable","CachedSyncIterable","constructor","Symbol","iterator","Object","TypeError","cached","cur","next","push","touchNext","count","idx","last","done","CachedAsyncIterable","asyncIterator","MESSAGE_ID_ATTRIBUTE","FluentElement","HTMLElement","getMessage","messageId","args","whitelist","_bundles","message","formatted","value","attributes","errors","formatPattern","forEach","name","includes","errorEvent","CustomEvent","bubbles","detail","dispatchEvent","Error","connectedCallback","render","newBundles","attributeWhitelist","newValue","messageArgs","observedAttributes","attributeChangedCallback","oldValue","semiSafeInnerHTML","el","template","document","createElement","innerHTML","content","childNodes","node","appendChild","customElements","define","getAttribute","firstElementChild","setAttribute"],"mappings":";AAuBC,aAhBM,SAASA,EAAcC,EAASC,GAC/B,OAACC,MAAMC,QAAQF,GAGZA,EAAIG,IAAIC,GAAMC,EAAeN,EAASK,IAFlCC,EAAeN,EAASC,GAOvC,SAASK,EAAeN,EAASK,GACxB,IAAA,MAAME,KAAUP,EACbO,GAAAA,EAAOC,WAAWH,GACXE,OAAAA,EAGR,OAAA,KACV,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,cAAA;;ACQA,aAxBM,eAAeE,EAAeT,EAASC,GACtC,IAACC,MAAMC,QAAQF,GAAM,CACV,UAAA,MAAMM,KAAUP,EACnBO,GAAAA,EAAOC,WAAWP,GACXM,OAAAA,EAGR,OAAA,KAELG,MAAAA,EAAe,IAAIR,MAAMD,EAAIU,QAAQC,KAAK,MAC5CC,IAAAA,EAAiBZ,EAAIU,OACd,UAAA,MAAMJ,KAAUP,EAClB,IAAA,MAAOc,EAAOT,KAAOJ,EAAIc,UAMtBF,IALCH,EAAaI,IAAUP,EAAOC,WAAWH,KAC1CK,EAAaI,GAASP,EACtBM,KAGmB,IAAnBA,EACOH,OAAAA,EAIZA,OAAAA,EACV,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,eAAA;;AC1BD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,OAAA,eAAA,QAAA,gBAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,iBAAA,OAAA,eAAA,QAAA,iBAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,kBADA,IAAA,EAAA,QAAA,iBACA,EAAA,QAAA;;ACFkD,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAAnC,MAAMM,UAAuBd,MASjCe,YAAKC,GACJA,OAAAA,aAAoB,KACbA,EAGJ,IAAI,KAAKA,IAd0B,QAAA,QAAA;;ACKa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAR/D,IAAA,EAAA,EAAA,QAAA,0BAQ+D,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAhD,MAAMC,UAA2BH,EAAjC,QAOXI,YAAYF,GAGJG,GAFJ,UAEIA,OAAOC,YAAYC,OAAOL,IAGpB,MAAA,IAAIM,UAAU,mDAFfF,KAAAA,SAAWJ,EAASG,OAAOC,YAMvCD,CAAAA,OAAOC,YACEG,MAAAA,EAAS,KACXC,IAAAA,EAAM,EAEH,MAAA,CACHC,KAAI,KACIF,EAAOd,QAAUe,GACjBD,EAAOG,KAAKH,EAAOH,SAASK,QAEzBF,EAAOC,OAW1BG,UAAUC,EAAQ,GACVC,IAAAA,EAAM,EACHA,KAAAA,IAAQD,GAAO,CACZE,MAAAA,EAAO,KAAK,KAAKrB,OAAS,GAC5BqB,GAAAA,GAAQA,EAAKC,KACb,MAECL,KAAAA,KAAK,KAAKN,SAASK,QAIrB,OAAA,KAAK,KAAKhB,OAAS,IAhD6B,QAAA,QAAA;;ACAC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EARhE,IAAA,EAAA,EAAA,QAAA,0BAQgE,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAjD,MAAMuB,UAA4BlB,EAAlC,QAOXI,YAAYF,GAGJG,GAFJ,QAEIA,OAAOc,iBAAiBZ,OAAOL,GAC1BI,KAAAA,SAAWJ,EAASG,OAAOc,qBAC7B,CAAA,KAAId,OAAOC,YAAYC,OAAOL,IAG3B,MAAA,IAAIM,UAAU,mDAFfF,KAAAA,SAAWJ,EAASG,OAAOC,aAcvCD,CAAAA,OAAOc,iBACEV,MAAAA,EAAS,KACXC,IAAAA,EAAM,EAEH,MAAA,CACGC,KAAN,UACQF,EAAOd,QAAUe,GACjBD,EAAOG,KAAKH,EAAOH,SAASK,QAEzBF,EAAOC,OAWpBG,gBAAUC,EAAQ,GAChBC,IAAAA,EAAM,EACHA,KAAAA,IAAQD,GAAO,CACZE,MAAAA,EAAO,KAAK,KAAKrB,OAAS,GAC5BqB,GAAAA,UAAeA,GAAMC,KACrB,MAECL,KAAAA,KAAK,KAAKN,SAASK,QAIrB,OAAA,KAAK,KAAKhB,OAAS,IA1D8B,QAAA,QAAA;;ACPhE,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,OAAA,eAAA,QAAA,qBAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,WAAA,OAAA,eAAA,QAAA,sBAAA,CAAA,YAAA,EAAA,IAAA,WAAA,OAAA,EAAA,WADA,IAAA,EAAA,EAAA,QAAA,+BACA,EAAA,EAAA,QAAA,gCAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA;;ACgHA,aAjHA,IAAA,EAAA,QAAA,oBACA,EAAA,QAAA,mBAEA,MAAMyB,EAAuB,YAE7B,MAAMC,UAAsBC,YAC1BC,YAAW,UAAEC,EAAF,KAAaC,EAAb,UAAmBC,EAAY,KACpC,GAAA,KAAKC,SAAU,CACXpC,MAAAA,GAAS,EAAc,EAAA,eAAA,KAAKoC,SAAUH,GAExCjC,GAAAA,EAAQ,CACJqC,MAAAA,EAAUrC,EAAOgC,WAAWC,GAE9BI,GAAAA,EAAS,CACLC,MAAAA,EAAY,CAAEC,MAAO,KAAMC,WAAY,IACzCC,IAAAA,EAAS,GAUTA,GARJH,EAAUC,MAAQvC,EAAO0C,cAAcL,EAAQE,MAAOL,EAAMO,GAE5DzB,OAAOR,QAAQ6B,EAAQG,YAAYG,QAAQ,EAAEC,EAAML,MAC7CJ,EAAUU,SAASD,KACrBN,EAAUE,WAAWI,GAAQ5C,EAAO0C,cAAcH,EAAOL,EAAMO,MAI/DA,EAAOrC,OAAS,EAAG,CACf0C,MAAAA,EAAa,IAAIC,YAAY,mBAAoB,CACrDC,SAAS,EACTC,OAAQ,CACNhB,UAAAA,EACAC,KAAAA,EACAG,QAAAA,EACAI,OAAAA,KAGCS,KAAAA,cAAcJ,GAGdR,OAAAA,EACF,CACCQ,MAAAA,EAAa,IAAIC,YAAY,mBAAoB,CACrDC,SAAS,EACTC,OAAQ,CACNhB,UAAAA,EACAC,KAAAA,EACAO,OAAQ,CAAC,IAAIU,MAAM,gCAGlBD,KAAAA,cAAcJ,KAKlB,OAAA,KAGTM,oBACOC,KAAAA,SAGH5D,YAAQ6D,GACLlB,KAAAA,SAAWxB,EAAmBF,mBAAAA,KAAK4C,GACnCD,KAAAA,SAGHE,uBAAmBpB,GAChBA,KAAAA,UAAYA,EACZkB,KAAAA,SAGHnB,SAAKsB,GACFC,KAAAA,YAAcD,EACdH,KAAAA,SAGIK,gCACF,MAAA,CAAC7B,GAGV8B,yBAAyBf,EAAMgB,EAAUJ,GACnCZ,IAASf,GAAwB+B,IAAaJ,GAC3CH,KAAAA,UAKX,SAASQ,EAAkBC,EAAIzB,GACzBA,GAAAA,EAAQE,OAA2B,UAAlBF,EAAQE,MAAmB,CACxCwB,MAAAA,EAAWC,SAASC,cAAc,YACxCF,EAASG,UAAY7B,EAAQE,MAC7BuB,EAAGI,UAAY,GACfvE,MAAMe,KAAKqD,EAASI,QAAQC,YAAYzB,QAAS0B,IAC/CP,EAAGQ,YAAYD,MAKrBE,eAAeC,OACb,cACA,cAAc1C,EACZuB,SACQhB,MAAAA,EAAU,KAAKL,WAAW,CAC9BC,UAAW,KAAKwC,aAAa5C,GAC7BK,KAAM,KAAKuB,cAGTpB,GACFwB,EAAkB,KAAMxB,MAMhCkC,eAAeC,OACb,iBACA,cAAc1C,EACZuB,SACM,GAAA,KAAKqB,kBAAmB,CACpBrC,MAAAA,EAAU,KAAKL,WAAW,CAC9BC,UAAW,KAAKwC,aAAa5C,GAC7BK,KAAM,KAAKuB,YACXtB,UAAW,KAAKA,YAGdE,IACFrB,OAAOR,QAAQ6B,EAAQG,YAAYG,QAAQ,EAAEC,EAAML,MAC5CmC,KAAAA,kBAAkBC,aAAa/B,EAAML,KAG5CsB,EAAkB,KAAKa,kBAAmBrC","file":"src.df1a007d.js","sourceRoot":"example/elm","sourcesContent":["/*\n * Synchronously map an identifier or an array of identifiers to the best\n * `FluentBundle` instance(s).\n *\n * @param bundles - An iterable of bundles to sift through.\n * @param ids - An id or ids to map.\n */\nexport function mapBundleSync(bundles, ids) {\n    if (!Array.isArray(ids)) {\n        return getBundleForId(bundles, ids);\n    }\n    return ids.map(id => getBundleForId(bundles, id));\n}\n/*\n * Find the best `FluentBundle` with the translation for `id`.\n */\nfunction getBundleForId(bundles, id) {\n    for (const bundle of bundles) {\n        if (bundle.hasMessage(id)) {\n            return bundle;\n        }\n    }\n    return null;\n}\n","/*\n * Asynchronously map an identifier or an array of identifiers to the best\n * `FluentBundle` instance(s).\n *\n * @param bundles - An iterable of bundles to sift through.\n * @param ids - An id or ids to map.\n */\nexport async function mapBundleAsync(bundles, ids) {\n    if (!Array.isArray(ids)) {\n        for await (const bundle of bundles) {\n            if (bundle.hasMessage(ids)) {\n                return bundle;\n            }\n        }\n        return null;\n    }\n    const foundBundles = new Array(ids.length).fill(null);\n    let remainingCount = ids.length;\n    for await (const bundle of bundles) {\n        for (const [index, id] of ids.entries()) {\n            if (!foundBundles[index] && bundle.hasMessage(id)) {\n                foundBundles[index] = bundle;\n                remainingCount--;\n            }\n            // Return early when all ids have been mapped to bundles.\n            if (remainingCount === 0) {\n                return foundBundles;\n            }\n        }\n    }\n    return foundBundles;\n}\n","/*\n * @module fluent-sequence\n * @overview Manage ordered sequences of FluentBundles.\n */\nexport { mapBundleSync } from \"./map_sync.js\";\nexport { mapBundleAsync } from \"./map_async.js\";\n","/*\n * Base CachedIterable class.\n */\nexport default class CachedIterable extends Array {\n    /**\n     * Create a `CachedIterable` instance from an iterable or, if another\n     * instance of `CachedIterable` is passed, return it without any\n     * modifications.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedIterable}\n     */\n    static from(iterable) {\n        if (iterable instanceof this) {\n            return iterable;\n        }\n\n        return new this(iterable);\n    }\n}\n","import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedSyncIterable caches the elements yielded by an iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedSyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedSyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedSyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    [Symbol.iterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && last.done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n","import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedAsyncIterable caches the elements yielded by an async iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedAsyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedAsyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedAsyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.asyncIterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.asyncIterator]();\n        } else if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    /**\n     * Asynchronous iterator caching the yielded elements.\n     *\n     * Elements yielded by the original iterable will be cached and available\n     * synchronously. Returns an async generator object implementing the\n     * iterator protocol over the elements of the original (async or sync)\n     * iterable.\n     */\n    [Symbol.asyncIterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            async next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    async touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && (await last).done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n","export {default as CachedSyncIterable} from \"./cached_sync_iterable.mjs\";\nexport {default as CachedAsyncIterable} from \"./cached_async_iterable.mjs\";\n","import { mapBundleSync } from \"@fluent/sequence\";\nimport { CachedSyncIterable } from \"cached-iterable\";\n\nconst MESSAGE_ID_ATTRIBUTE = \"messageId\";\n\nclass FluentElement extends HTMLElement {\n  getMessage({ messageId, args, whitelist = [] }) {\n    if (this._bundles) {\n      const bundle = mapBundleSync(this._bundles, messageId);\n\n      if (bundle) {\n        const message = bundle.getMessage(messageId);\n\n        if (message) {\n          const formatted = { value: null, attributes: {} };\n          let errors = [];\n\n          formatted.value = bundle.formatPattern(message.value, args, errors);\n\n          Object.entries(message.attributes).forEach(([name, value]) => {\n            if (whitelist.includes(name)) {\n              formatted.attributes[name] = bundle.formatPattern(value, args, errors);\n            }\n          });\n\n          if (errors.length > 0) {\n            const errorEvent = new CustomEvent(\"fluent-web-error\", {\n              bubbles: true,\n              detail: {\n                messageId,\n                args,\n                message,\n                errors,\n              },\n            });\n            this.dispatchEvent(errorEvent);\n          }\n\n          return formatted;\n        } else {\n          const errorEvent = new CustomEvent(\"fluent-web-error\", {\n            bubbles: true,\n            detail: {\n              messageId,\n              args,\n              errors: [new Error(\"Message object not found\")],\n            },\n          });\n          this.dispatchEvent(errorEvent);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  connectedCallback() {\n    this.render();\n  }\n\n  set bundles(newBundles) {\n    this._bundles = CachedSyncIterable.from(newBundles);\n    this.render();\n  }\n\n  set attributeWhitelist(whitelist) {\n    this.whitelist = whitelist;\n    this.render();\n  }\n\n  set args(newValue) {\n    this.messageArgs = newValue;\n    this.render();\n  }\n\n  static get observedAttributes() {\n    return [MESSAGE_ID_ATTRIBUTE];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === MESSAGE_ID_ATTRIBUTE && oldValue !== newValue) {\n      this.render();\n    }\n  }\n}\n\nfunction semiSafeInnerHTML(el, message) {\n  if (message.value && message.value !== \"{???}\") {\n    const template = document.createElement(\"template\");\n    template.innerHTML = message.value;\n    el.innerHTML = \"\";\n    Array.from(template.content.childNodes).forEach((node) => {\n      el.appendChild(node);\n    });\n  }\n}\n\ncustomElements.define(\n  \"fluent-text\",\n  class extends FluentElement {\n    render() {\n      const message = this.getMessage({\n        messageId: this.getAttribute(MESSAGE_ID_ATTRIBUTE),\n        args: this.messageArgs,\n      });\n\n      if (message) {\n        semiSafeInnerHTML(this, message);\n      }\n    }\n  }\n);\n\ncustomElements.define(\n  \"fluent-element\",\n  class extends FluentElement {\n    render() {\n      if (this.firstElementChild) {\n        const message = this.getMessage({\n          messageId: this.getAttribute(MESSAGE_ID_ATTRIBUTE),\n          args: this.messageArgs,\n          whitelist: this.whitelist\n        });\n\n        if (message) {\n          Object.entries(message.attributes).forEach(([name, value]) => {\n            this.firstElementChild.setAttribute(name, value);\n          });\n\n          semiSafeInnerHTML(this.firstElementChild, message);\n        }\n      }\n    }\n  }\n);\n"]}