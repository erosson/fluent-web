{"version":3,"sources":["../../node_modules/@fluent/bundle/esm/types.js","../../node_modules/@fluent/bundle/esm/resolver.js","../../node_modules/@fluent/bundle/esm/scope.js","../../node_modules/@fluent/bundle/esm/builtins.js","../../node_modules/@fluent/bundle/esm/bundle.js","../../node_modules/@fluent/bundle/esm/resource.js","../../node_modules/@fluent/bundle/esm/index.js","../../node_modules/@fluent/sequence/esm/map_sync.js","../../node_modules/@fluent/sequence/esm/map_async.js","../../node_modules/@fluent/sequence/esm/index.js","../../node_modules/cached-iterable/src/cached_iterable.mjs","../../node_modules/cached-iterable/src/cached_sync_iterable.mjs","../../node_modules/cached-iterable/src/cached_async_iterable.mjs","../../node_modules/cached-iterable/src/index.mjs","../../src/index.js"],"names":["FluentType","constructor","value","valueOf","FluentNone","toString","scope","FluentNumber","opts","nf","memoizeIntlObject","Intl","NumberFormat","format","err","reportError","FluentDateTime","dtf","DateTimeFormat","Date","toISOString","MAX_PLACEABLES","FSI","PDI","match","selector","key","PluralRules","select","getDefault","variants","star","resolvePattern","RangeError","getArguments","args","positional","named","Object","create","arg","type","name","resolveExpression","push","expr","minimumFractionDigits","precision","resolveVariableReference","resolveMessageReference","resolveTermReference","resolveFunctionReference","resolveSelectExpression","params","prototype","hasOwnProperty","call","ReferenceError","getTime","TypeError","attr","message","bundle","_messages","get","attribute","attributes","id","term","_terms","resolved","func","_functions","sel","variant","resolveComplexPattern","ptn","dirty","has","add","result","useIsolating","_useIsolating","length","elem","placeables","delete","_transform","join","Scope","errors","WeakSet","error","ctor","cache","_intls","set","JSON","stringify","locales","values","allowed","unwrapped","opt","entries","includes","NUMBER_ALLOWED","NUMBER","DATETIME_ALLOWED","DATETIME","FluentBundle","functions","transform","v","Map","WeakMap","Array","isArray","hasMessage","getMessage","addResource","res","allowOverrides","i","body","entry","startsWith","Error","formatPattern","pattern","RE_MESSAGE_START","RE_ATTRIBUTE_START","RE_VARIANT_START","RE_NUMBER_LITERAL","RE_IDENTIFIER","RE_REFERENCE","RE_FUNCTION_NAME","RE_TEXT_RUN","RE_STRING_RUN","RE_STRING_ESCAPE","RE_UNICODE_ESCAPE","RE_LEADING_NEWLINES","RE_TRAILING_SPACES","RE_BLANK_LINES","RE_INDENT","TOKEN_BRACE_OPEN","TOKEN_BRACE_CLOSE","TOKEN_BRACKET_OPEN","TOKEN_BRACKET_CLOSE","TOKEN_PAREN_OPEN","TOKEN_ARROW","TOKEN_COLON","TOKEN_COMMA","TOKEN_BLANK","FluentResource","source","lastIndex","cursor","next","exec","parseMessage","SyntaxError","test","re","consumeChar","char","errorClass","consumeToken","match1","parsePattern","parseAttributes","attrs","keys","first","parsePatternElements","Infinity","indent","parseIndent","trim","elements","commonIndent","parsePlaceable","Math","min","lastElement","baked","element","Indent","slice","parseInlineExpression","parseVariants","count","parseVariantKey","undefined","sigil","parseArguments","parseArgument","parseLiteral","parseNumberLiteral","parseStringLiteral","parseEscapeSequence","fraction","parseFloat","codepoint4","codepoint6","codepoint","parseInt","String","fromCodePoint","start","makeIndent","text","replace","blank","mapBundleSync","bundles","ids","map","getBundleForId","mapBundleAsync","foundBundles","fill","remainingCount","index","CachedIterable","from","iterable","CachedSyncIterable","Symbol","iterator","cached","cur","touchNext","idx","last","done","CachedAsyncIterable","asyncIterator","internalAttributes","parsedBundles","fetchedMessages","locale","messages","resource","customElements","define","HTMLElement","window","fluentWeb","FluentWeb","connectedCallback","render","newValue","buildBundles","messageArgs","observedAttributes","attributeChangedCallback","oldValue","setBundles","messageId","getAttribute","template","document","createElement","innerHTML","content","childNodes","forEach","node","appendChild","firstElementChild","val","setAttribute","getAttributeNames"],"mappings":"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","file":"src.ea1789c9.js","sourceRoot":"example/elm","sourcesContent":["/**\n * The `FluentType` class is the base of Fluent's type system.\n *\n * Fluent types wrap JavaScript values and store additional configuration for\n * them, which can then be used in the `toString` method together with a proper\n * `Intl` formatter.\n */\nexport class FluentType {\n    /**\n     * Create a `FluentType` instance.\n     *\n     * @param value The JavaScript value to wrap.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Unwrap the raw value stored by this `FluentType`.\n     */\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * A `FluentType` representing no correct value.\n */\nexport class FluentNone extends FluentType {\n    /**\n     * Create an instance of `FluentNone` with an optional fallback value.\n     * @param value The fallback value of this `FluentNone`.\n     */\n    constructor(value = \"???\") {\n        super(value);\n    }\n    /**\n     * Format this `FluentNone` to the fallback string.\n     */\n    toString(scope) {\n        return `{${this.value}}`;\n    }\n}\n/**\n * A `FluentType` representing a number.\n *\n * A `FluentNumber` instance stores the number value of the number it\n * represents. It may also store an option bag of options which will be passed\n * to `Intl.NumerFormat` when the `FluentNumber` is formatted to a string.\n */\nexport class FluentNumber extends FluentType {\n    /**\n     * Create an instance of `FluentNumber` with options to the\n     * `Intl.NumberFormat` constructor.\n     *\n     * @param value The number value of this `FluentNumber`.\n     * @param opts Options which will be passed to `Intl.NumberFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentNumber` to a string.\n     */\n    toString(scope) {\n        try {\n            const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);\n            return nf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return this.value.toString(10);\n        }\n    }\n}\n/**\n * A `FluentType` representing a date and time.\n *\n * A `FluentDateTime` instance stores the number value of the date it\n * represents, as a numerical timestamp in milliseconds. It may also store an\n * option bag of options which will be passed to `Intl.DateTimeFormat` when the\n * `FluentDateTime` is formatted to a string.\n */\nexport class FluentDateTime extends FluentType {\n    /**\n     * Create an instance of `FluentDateTime` with options to the\n     * `Intl.DateTimeFormat` constructor.\n     *\n     * @param value The number value of this `FluentDateTime`, in milliseconds.\n     * @param opts Options which will be passed to `Intl.DateTimeFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentDateTime` to a string.\n     */\n    toString(scope) {\n        try {\n            const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);\n            return dtf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return new Date(this.value).toISOString();\n        }\n    }\n}\n","/* global Intl */\n/**\n * @overview\n *\n * The role of the Fluent resolver is to format a `Pattern` to an instance of\n * `FluentValue`. For performance reasons, primitive strings are considered\n * such instances, too.\n *\n * Translations can contain references to other messages or variables,\n * conditional logic in form of select expressions, traits which describe their\n * grammatical features, and can use Fluent builtins which make use of the\n * `Intl` formatters to format numbers and dates into the bundle's languages.\n * See the documentation of the Fluent syntax for more information.\n *\n * In case of errors the resolver will try to salvage as much of the\n * translation as possible. In rare situations where the resolver didn't know\n * how to recover from an error it will return an instance of `FluentNone`.\n *\n * All expressions resolve to an instance of `FluentValue`. The caller should\n * use the `toString` method to convert the instance to a native value.\n *\n * Functions in this file pass around an instance of the `Scope` class, which\n * stores the data required for successful resolution and error recovery.\n */\nimport { FluentType, FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\n// The maximum number of placeables which can be expanded in a single call to\n// `formatPattern`. The limit protects against the Billion Laughs and Quadratic\n// Blowup attacks. See https://msdn.microsoft.com/en-us/magazine/ee335713.aspx.\nconst MAX_PLACEABLES = 100;\n// Unicode bidi isolation characters.\nconst FSI = \"\\u2068\";\nconst PDI = \"\\u2069\";\n// Helper: match a variant key to the given selector.\nfunction match(scope, selector, key) {\n    if (key === selector) {\n        // Both are strings.\n        return true;\n    }\n    // XXX Consider comparing options too, e.g. minimumFractionDigits.\n    if (key instanceof FluentNumber &&\n        selector instanceof FluentNumber &&\n        key.value === selector.value) {\n        return true;\n    }\n    if (selector instanceof FluentNumber && typeof key === \"string\") {\n        let category = scope\n            .memoizeIntlObject(Intl.PluralRules, selector.opts)\n            .select(selector.value);\n        if (key === category) {\n            return true;\n        }\n    }\n    return false;\n}\n// Helper: resolve the default variant from a list of variants.\nfunction getDefault(scope, variants, star) {\n    if (variants[star]) {\n        return resolvePattern(scope, variants[star].value);\n    }\n    scope.reportError(new RangeError(\"No default\"));\n    return new FluentNone();\n}\n// Helper: resolve arguments to a call expression.\nfunction getArguments(scope, args) {\n    const positional = [];\n    const named = Object.create(null);\n    for (const arg of args) {\n        if (arg.type === \"narg\") {\n            named[arg.name] = resolveExpression(scope, arg.value);\n        }\n        else {\n            positional.push(resolveExpression(scope, arg));\n        }\n    }\n    return { positional, named };\n}\n// Resolve an expression to a Fluent type.\nfunction resolveExpression(scope, expr) {\n    switch (expr.type) {\n        case \"str\":\n            return expr.value;\n        case \"num\":\n            return new FluentNumber(expr.value, {\n                minimumFractionDigits: expr.precision\n            });\n        case \"var\":\n            return resolveVariableReference(scope, expr);\n        case \"mesg\":\n            return resolveMessageReference(scope, expr);\n        case \"term\":\n            return resolveTermReference(scope, expr);\n        case \"func\":\n            return resolveFunctionReference(scope, expr);\n        case \"select\":\n            return resolveSelectExpression(scope, expr);\n        default:\n            return new FluentNone();\n    }\n}\n// Resolve a reference to a variable.\nfunction resolveVariableReference(scope, { name }) {\n    let arg;\n    if (scope.params) {\n        // We're inside a TermReference. It's OK to reference undefined parameters.\n        if (Object.prototype.hasOwnProperty.call(scope.params, name)) {\n            arg = scope.params[name];\n        }\n        else {\n            return new FluentNone(`$${name}`);\n        }\n    }\n    else if (scope.args\n        && Object.prototype.hasOwnProperty.call(scope.args, name)) {\n        // We're in the top-level Pattern or inside a MessageReference. Missing\n        // variables references produce ReferenceErrors.\n        arg = scope.args[name];\n    }\n    else {\n        scope.reportError(new ReferenceError(`Unknown variable: $${name}`));\n        return new FluentNone(`$${name}`);\n    }\n    // Return early if the argument already is an instance of FluentType.\n    if (arg instanceof FluentType) {\n        return arg;\n    }\n    // Convert the argument to a Fluent type.\n    switch (typeof arg) {\n        case \"string\":\n            return arg;\n        case \"number\":\n            return new FluentNumber(arg);\n        case \"object\":\n            if (arg instanceof Date) {\n                return new FluentDateTime(arg.getTime());\n            }\n        // eslint-disable-next-line no-fallthrough\n        default:\n            scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));\n            return new FluentNone(`$${name}`);\n    }\n}\n// Resolve a reference to another message.\nfunction resolveMessageReference(scope, { name, attr }) {\n    const message = scope.bundle._messages.get(name);\n    if (!message) {\n        scope.reportError(new ReferenceError(`Unknown message: ${name}`));\n        return new FluentNone(name);\n    }\n    if (attr) {\n        const attribute = message.attributes[attr];\n        if (attribute) {\n            return resolvePattern(scope, attribute);\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${name}.${attr}`);\n    }\n    if (message.value) {\n        return resolvePattern(scope, message.value);\n    }\n    scope.reportError(new ReferenceError(`No value: ${name}`));\n    return new FluentNone(name);\n}\n// Resolve a call to a Term with key-value arguments.\nfunction resolveTermReference(scope, { name, attr, args }) {\n    const id = `-${name}`;\n    const term = scope.bundle._terms.get(id);\n    if (!term) {\n        scope.reportError(new ReferenceError(`Unknown term: ${id}`));\n        return new FluentNone(id);\n    }\n    if (attr) {\n        const attribute = term.attributes[attr];\n        if (attribute) {\n            // Every TermReference has its own variables.\n            scope.params = getArguments(scope, args).named;\n            const resolved = resolvePattern(scope, attribute);\n            scope.params = null;\n            return resolved;\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${id}.${attr}`);\n    }\n    scope.params = getArguments(scope, args).named;\n    const resolved = resolvePattern(scope, term.value);\n    scope.params = null;\n    return resolved;\n}\n// Resolve a call to a Function with positional and key-value arguments.\nfunction resolveFunctionReference(scope, { name, args }) {\n    // Some functions are built-in. Others may be provided by the runtime via\n    // the `FluentBundle` constructor.\n    let func = scope.bundle._functions[name];\n    if (!func) {\n        scope.reportError(new ReferenceError(`Unknown function: ${name}()`));\n        return new FluentNone(`${name}()`);\n    }\n    if (typeof func !== \"function\") {\n        scope.reportError(new TypeError(`Function ${name}() is not callable`));\n        return new FluentNone(`${name}()`);\n    }\n    try {\n        let resolved = getArguments(scope, args);\n        return func(resolved.positional, resolved.named);\n    }\n    catch (err) {\n        scope.reportError(err);\n        return new FluentNone(`${name}()`);\n    }\n}\n// Resolve a select expression to the member object.\nfunction resolveSelectExpression(scope, { selector, variants, star }) {\n    let sel = resolveExpression(scope, selector);\n    if (sel instanceof FluentNone) {\n        return getDefault(scope, variants, star);\n    }\n    // Match the selector against keys of each variant, in order.\n    for (const variant of variants) {\n        const key = resolveExpression(scope, variant.key);\n        if (match(scope, sel, key)) {\n            return resolvePattern(scope, variant.value);\n        }\n    }\n    return getDefault(scope, variants, star);\n}\n// Resolve a pattern (a complex string with placeables).\nexport function resolveComplexPattern(scope, ptn) {\n    if (scope.dirty.has(ptn)) {\n        scope.reportError(new RangeError(\"Cyclic reference\"));\n        return new FluentNone();\n    }\n    // Tag the pattern as dirty for the purpose of the current resolution.\n    scope.dirty.add(ptn);\n    const result = [];\n    // Wrap interpolations with Directional Isolate Formatting characters\n    // only when the pattern has more than one element.\n    const useIsolating = scope.bundle._useIsolating && ptn.length > 1;\n    for (const elem of ptn) {\n        if (typeof elem === \"string\") {\n            result.push(scope.bundle._transform(elem));\n            continue;\n        }\n        scope.placeables++;\n        if (scope.placeables > MAX_PLACEABLES) {\n            scope.dirty.delete(ptn);\n            // This is a fatal error which causes the resolver to instantly bail out\n            // on this pattern. The length check protects against excessive memory\n            // usage, and throwing protects against eating up the CPU when long\n            // placeables are deeply nested.\n            throw new RangeError(`Too many placeables expanded: ${scope.placeables}, ` +\n                `max allowed is ${MAX_PLACEABLES}`);\n        }\n        if (useIsolating) {\n            result.push(FSI);\n        }\n        result.push(resolveExpression(scope, elem).toString(scope));\n        if (useIsolating) {\n            result.push(PDI);\n        }\n    }\n    scope.dirty.delete(ptn);\n    return result.join(\"\");\n}\n// Resolve a simple or a complex Pattern to a FluentString (which is really the\n// string primitive).\nfunction resolvePattern(scope, value) {\n    // Resolve a simple pattern.\n    if (typeof value === \"string\") {\n        return scope.bundle._transform(value);\n    }\n    return resolveComplexPattern(scope, value);\n}\n","export class Scope {\n    constructor(bundle, errors, args) {\n        /** The Set of patterns already encountered during this resolution.\n         * Used to detect and prevent cyclic resolutions. */\n        this.dirty = new WeakSet();\n        /** A dict of parameters passed to a TermReference. */\n        this.params = null;\n        /** The running count of placeables resolved so far. Used to detect the\n          * Billion Laughs and Quadratic Blowup attacks. */\n        this.placeables = 0;\n        this.bundle = bundle;\n        this.errors = errors;\n        this.args = args;\n    }\n    reportError(error) {\n        if (!this.errors) {\n            throw error;\n        }\n        this.errors.push(error);\n    }\n    memoizeIntlObject(ctor, opts) {\n        let cache = this.bundle._intls.get(ctor);\n        if (!cache) {\n            cache = {};\n            this.bundle._intls.set(ctor, cache);\n        }\n        let id = JSON.stringify(opts);\n        if (!cache[id]) {\n            cache[id] = new ctor(this.bundle.locales, opts);\n        }\n        return cache[id];\n    }\n}\n","/**\n * @overview\n *\n * The FTL resolver ships with a number of functions built-in.\n *\n * Each function take two arguments:\n *   - args - an array of positional args\n *   - opts - an object of key-value args\n *\n * Arguments to functions are guaranteed to already be instances of\n * `FluentValue`.  Functions must return `FluentValues` as well.\n */\nimport { FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\nfunction values(opts, allowed) {\n    const unwrapped = Object.create(null);\n    for (const [name, opt] of Object.entries(opts)) {\n        if (allowed.includes(name)) {\n            unwrapped[name] = opt.valueOf();\n        }\n    }\n    return unwrapped;\n}\nconst NUMBER_ALLOWED = [\n    \"unitDisplay\",\n    \"currencyDisplay\",\n    \"useGrouping\",\n    \"minimumIntegerDigits\",\n    \"minimumFractionDigits\",\n    \"maximumFractionDigits\",\n    \"minimumSignificantDigits\",\n    \"maximumSignificantDigits\",\n];\n/**\n * The implementation of the `NUMBER()` builtin available to translations.\n *\n * Translations may call the `NUMBER()` builtin in order to specify formatting\n * options of a number. For example:\n *\n *     pi = The value of π is {NUMBER($pi, maximumFractionDigits: 2)}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     unitDisplay\n *     currencyDisplay\n *     useGrouping\n *     minimumIntegerDigits\n *     minimumFractionDigits\n *     maximumFractionDigits\n *     minimumSignificantDigits\n *     maximumSignificantDigits\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `NUMBER()`.\n * @param opts The named argments passed to this `NUMBER()`.\n */\nexport function NUMBER(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`NUMBER(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentNumber || arg instanceof FluentDateTime) {\n        return new FluentNumber(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, NUMBER_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to NUMBER\");\n}\nconst DATETIME_ALLOWED = [\n    \"dateStyle\",\n    \"timeStyle\",\n    \"fractionalSecondDigits\",\n    \"dayPeriod\",\n    \"hour12\",\n    \"weekday\",\n    \"era\",\n    \"year\",\n    \"month\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"timeZoneName\",\n];\n/**\n * The implementation of the `DATETIME()` builtin available to translations.\n *\n * Translations may call the `DATETIME()` builtin in order to specify\n * formatting options of a number. For example:\n *\n *     now = It's {DATETIME($today, month: \"long\")}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     dateStyle\n *     timeStyle\n *     fractionalSecondDigits\n *     dayPeriod\n *     hour12\n *     weekday\n *     era\n *     year\n *     month\n *     day\n *     hour\n *     minute\n *     second\n *     timeZoneName\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `DATETIME()`.\n * @param opts The named argments passed to this `DATETIME()`.\n */\nexport function DATETIME(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`DATETIME(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentNumber || arg instanceof FluentDateTime) {\n        return new FluentDateTime(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, DATETIME_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to DATETIME\");\n}\n","import { resolveComplexPattern } from \"./resolver.js\";\nimport { Scope } from \"./scope.js\";\nimport { FluentNone } from \"./types.js\";\nimport { NUMBER, DATETIME } from \"./builtins.js\";\n/**\n * Message bundles are single-language stores of translation resources. They are\n * responsible for formatting message values and attributes to strings.\n */\nexport class FluentBundle {\n    /**\n     * Create an instance of `FluentBundle`.\n     *\n     * The `locales` argument is used to instantiate `Intl` formatters used by\n     * translations. The `options` object can be used to configure the bundle.\n     *\n     * Examples:\n     *\n     *     let bundle = new FluentBundle([\"en-US\", \"en\"]);\n     *\n     *     let bundle = new FluentBundle(locales, {useIsolating: false});\n     *\n     *     let bundle = new FluentBundle(locales, {\n     *       useIsolating: true,\n     *       functions: {\n     *         NODE_ENV: () => process.env.NODE_ENV\n     *       }\n     *     });\n     *\n     * Available options:\n     *\n     *   - `functions` - an object of additional functions available to\n     *     translations as builtins.\n     *\n     *   - `useIsolating` - boolean specifying whether to use Unicode isolation\n     *     marks (FSI, PDI) for bidi interpolations. Default: `true`.\n     *\n     *   - `transform` - a function used to transform string parts of patterns.\n     */\n    constructor(locales, { functions, useIsolating = true, transform = (v) => v } = {}) {\n        this._terms = new Map();\n        this._messages = new Map();\n        this._intls = new WeakMap();\n        this.locales = Array.isArray(locales) ? locales : [locales];\n        this._functions = {\n            NUMBER,\n            DATETIME,\n            ...functions\n        };\n        this._useIsolating = useIsolating;\n        this._transform = transform;\n    }\n    /**\n     * Check if a message is present in the bundle.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    hasMessage(id) {\n        return this._messages.has(id);\n    }\n    /**\n     * Return a raw unformatted message object from the bundle.\n     *\n     * Raw messages are `{value, attributes}` shapes containing translation units\n     * called `Patterns`. `Patterns` are implementation-specific; they should be\n     * treated as black boxes and formatted with `FluentBundle.formatPattern`.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    getMessage(id) {\n        return this._messages.get(id);\n    }\n    /**\n     * Add a translation resource to the bundle.\n     *\n     * The translation resource must be an instance of `FluentResource`.\n     *\n     *     let res = new FluentResource(\"foo = Foo\");\n     *     bundle.addResource(res);\n     *     bundle.getMessage(\"foo\");\n     *     // → {value: .., attributes: {..}}\n     *\n     * Available options:\n     *\n     *   - `allowOverrides` - boolean specifying whether it's allowed to override\n     *     an existing message or term with a new value. Default: `false`.\n     *\n     * @param   res - FluentResource object.\n     * @param   options\n     */\n    addResource(res, { allowOverrides = false } = {}) {\n        const errors = [];\n        for (let i = 0; i < res.body.length; i++) {\n            let entry = res.body[i];\n            if (entry.id.startsWith(\"-\")) {\n                // Identifiers starting with a dash (-) define terms. Terms are private\n                // and cannot be retrieved from FluentBundle.\n                if (allowOverrides === false && this._terms.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing term: \"${entry.id}\"`));\n                    continue;\n                }\n                this._terms.set(entry.id, entry);\n            }\n            else {\n                if (allowOverrides === false && this._messages.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing message: \"${entry.id}\"`));\n                    continue;\n                }\n                this._messages.set(entry.id, entry);\n            }\n        }\n        return errors;\n    }\n    /**\n     * Format a `Pattern` to a string.\n     *\n     * Format a raw `Pattern` into a string. `args` will be used to resolve\n     * references to variables passed as arguments to the translation.\n     *\n     * In case of errors `formatPattern` will try to salvage as much of the\n     * translation as possible and will still return a string. For performance\n     * reasons, the encountered errors are not returned but instead are appended\n     * to the `errors` array passed as the third argument.\n     *\n     *     let errors = [];\n     *     bundle.addResource(\n     *         new FluentResource(\"hello = Hello, {$name}!\"));\n     *\n     *     let hello = bundle.getMessage(\"hello\");\n     *     if (hello.value) {\n     *         bundle.formatPattern(hello.value, {name: \"Jane\"}, errors);\n     *         // Returns \"Hello, Jane!\" and `errors` is empty.\n     *\n     *         bundle.formatPattern(hello.value, undefined, errors);\n     *         // Returns \"Hello, {$name}!\" and `errors` is now:\n     *         // [<ReferenceError: Unknown variable: name>]\n     *     }\n     *\n     * If `errors` is omitted, the first encountered error will be thrown.\n     */\n    formatPattern(pattern, args = null, errors = null) {\n        // Resolve a simple pattern without creating a scope. No error handling is\n        // required; by definition simple patterns don't have placeables.\n        if (typeof pattern === \"string\") {\n            return this._transform(pattern);\n        }\n        // Resolve a complex pattern.\n        let scope = new Scope(this, errors, args);\n        try {\n            let value = resolveComplexPattern(scope, pattern);\n            return value.toString(scope);\n        }\n        catch (err) {\n            if (scope.errors) {\n                scope.errors.push(err);\n                return new FluentNone().toString(scope);\n            }\n            throw err;\n        }\n    }\n}\n","// This regex is used to iterate through the beginnings of messages and terms.\n// With the /m flag, the ^ matches at the beginning of every line.\nconst RE_MESSAGE_START = /^(-?[a-zA-Z][\\w-]*) *= */gm;\n// Both Attributes and Variants are parsed in while loops. These regexes are\n// used to break out of them.\nconst RE_ATTRIBUTE_START = /\\.([a-zA-Z][\\w-]*) *= */y;\nconst RE_VARIANT_START = /\\*?\\[/y;\nconst RE_NUMBER_LITERAL = /(-?[0-9]+(?:\\.([0-9]+))?)/y;\nconst RE_IDENTIFIER = /([a-zA-Z][\\w-]*)/y;\nconst RE_REFERENCE = /([$-])?([a-zA-Z][\\w-]*)(?:\\.([a-zA-Z][\\w-]*))?/y;\nconst RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;\n// A \"run\" is a sequence of text or string literal characters which don't\n// require any special handling. For TextElements such special characters are: {\n// (starts a placeable), and line breaks which require additional logic to check\n// if the next line is indented. For StringLiterals they are: \\ (starts an\n// escape sequence), \" (ends the literal), and line breaks which are not allowed\n// in StringLiterals. Note that string runs may be empty; text runs may not.\nconst RE_TEXT_RUN = /([^{}\\n\\r]+)/y;\nconst RE_STRING_RUN = /([^\\\\\"\\n\\r]*)/y;\n// Escape sequences.\nconst RE_STRING_ESCAPE = /\\\\([\\\\\"])/y;\nconst RE_UNICODE_ESCAPE = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{6})/y;\n// Used for trimming TextElements and indents.\nconst RE_LEADING_NEWLINES = /^\\n+/;\nconst RE_TRAILING_SPACES = / +$/;\n// Used in makeIndent to strip spaces from blank lines and normalize CRLF to LF.\nconst RE_BLANK_LINES = / *\\r?\\n/g;\n// Used in makeIndent to measure the indentation.\nconst RE_INDENT = /( *)$/;\n// Common tokens.\nconst TOKEN_BRACE_OPEN = /{\\s*/y;\nconst TOKEN_BRACE_CLOSE = /\\s*}/y;\nconst TOKEN_BRACKET_OPEN = /\\[\\s*/y;\nconst TOKEN_BRACKET_CLOSE = /\\s*] */y;\nconst TOKEN_PAREN_OPEN = /\\s*\\(\\s*/y;\nconst TOKEN_ARROW = /\\s*->\\s*/y;\nconst TOKEN_COLON = /\\s*:\\s*/y;\n// Note the optional comma. As a deviation from the Fluent EBNF, the parser\n// doesn't enforce commas between call arguments.\nconst TOKEN_COMMA = /\\s*,?\\s*/y;\nconst TOKEN_BLANK = /\\s+/y;\n/**\n * Fluent Resource is a structure storing parsed localization entries.\n */\nexport class FluentResource {\n    constructor(source) {\n        this.body = [];\n        RE_MESSAGE_START.lastIndex = 0;\n        let cursor = 0;\n        // Iterate over the beginnings of messages and terms to efficiently skip\n        // comments and recover from errors.\n        while (true) {\n            let next = RE_MESSAGE_START.exec(source);\n            if (next === null) {\n                break;\n            }\n            cursor = RE_MESSAGE_START.lastIndex;\n            try {\n                this.body.push(parseMessage(next[1]));\n            }\n            catch (err) {\n                if (err instanceof SyntaxError) {\n                    // Don't report any Fluent syntax errors. Skip directly to the\n                    // beginning of the next message or term.\n                    continue;\n                }\n                throw err;\n            }\n        }\n        // The parser implementation is inlined below for performance reasons,\n        // as well as for convenience of accessing `source` and `cursor`.\n        // The parser focuses on minimizing the number of false negatives at the\n        // expense of increasing the risk of false positives. In other words, it\n        // aims at parsing valid Fluent messages with a success rate of 100%, but it\n        // may also parse a few invalid messages which the reference parser would\n        // reject. The parser doesn't perform any validation and may produce entries\n        // which wouldn't make sense in the real world. For best results users are\n        // advised to validate translations with the fluent-syntax parser\n        // pre-runtime.\n        // The parser makes an extensive use of sticky regexes which can be anchored\n        // to any offset of the source string without slicing it. Errors are thrown\n        // to bail out of parsing of ill-formed messages.\n        function test(re) {\n            re.lastIndex = cursor;\n            return re.test(source);\n        }\n        // Advance the cursor by the char if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeChar(char, errorClass) {\n            if (source[cursor] === char) {\n                cursor++;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${char}`);\n            }\n            return false;\n        }\n        // Advance the cursor by the token if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeToken(re, errorClass) {\n            if (test(re)) {\n                cursor = re.lastIndex;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${re.toString()}`);\n            }\n            return false;\n        }\n        // Execute a regex, advance the cursor, and return all capture groups.\n        function match(re) {\n            re.lastIndex = cursor;\n            let result = re.exec(source);\n            if (result === null) {\n                throw new SyntaxError(`Expected ${re.toString()}`);\n            }\n            cursor = re.lastIndex;\n            return result;\n        }\n        // Execute a regex, advance the cursor, and return the capture group.\n        function match1(re) {\n            return match(re)[1];\n        }\n        function parseMessage(id) {\n            let value = parsePattern();\n            let attributes = parseAttributes();\n            if (value === null && Object.keys(attributes).length === 0) {\n                throw new SyntaxError(\"Expected message value or attributes\");\n            }\n            return { id, value, attributes };\n        }\n        function parseAttributes() {\n            let attrs = Object.create(null);\n            while (test(RE_ATTRIBUTE_START)) {\n                let name = match1(RE_ATTRIBUTE_START);\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected attribute value\");\n                }\n                attrs[name] = value;\n            }\n            return attrs;\n        }\n        function parsePattern() {\n            let first;\n            // First try to parse any simple text on the same line as the id.\n            if (test(RE_TEXT_RUN)) {\n                first = match1(RE_TEXT_RUN);\n            }\n            // If there's a placeable on the first line, parse a complex pattern.\n            if (source[cursor] === \"{\" || source[cursor] === \"}\") {\n                // Re-use the text parsed above, if possible.\n                return parsePatternElements(first ? [first] : [], Infinity);\n            }\n            // RE_TEXT_VALUE stops at newlines. Only continue parsing the pattern if\n            // what comes after the newline is indented.\n            let indent = parseIndent();\n            if (indent) {\n                if (first) {\n                    // If there's text on the first line, the blank block is part of the\n                    // translation content in its entirety.\n                    return parsePatternElements([first, indent], indent.length);\n                }\n                // Otherwise, we're dealing with a block pattern, i.e. a pattern which\n                // starts on a new line. Discrad the leading newlines but keep the\n                // inline indent; it will be used by the dedentation logic.\n                indent.value = trim(indent.value, RE_LEADING_NEWLINES);\n                return parsePatternElements([indent], indent.length);\n            }\n            if (first) {\n                // It was just a simple inline text after all.\n                return trim(first, RE_TRAILING_SPACES);\n            }\n            return null;\n        }\n        // Parse a complex pattern as an array of elements.\n        function parsePatternElements(elements = [], commonIndent) {\n            while (true) {\n                if (test(RE_TEXT_RUN)) {\n                    elements.push(match1(RE_TEXT_RUN));\n                    continue;\n                }\n                if (source[cursor] === \"{\") {\n                    elements.push(parsePlaceable());\n                    continue;\n                }\n                if (source[cursor] === \"}\") {\n                    throw new SyntaxError(\"Unbalanced closing brace\");\n                }\n                let indent = parseIndent();\n                if (indent) {\n                    elements.push(indent);\n                    commonIndent = Math.min(commonIndent, indent.length);\n                    continue;\n                }\n                break;\n            }\n            let lastIndex = elements.length - 1;\n            let lastElement = elements[lastIndex];\n            // Trim the trailing spaces in the last element if it's a TextElement.\n            if (typeof lastElement === \"string\") {\n                elements[lastIndex] = trim(lastElement, RE_TRAILING_SPACES);\n            }\n            let baked = [];\n            for (let element of elements) {\n                if (element instanceof Indent) {\n                    // Dedent indented lines by the maximum common indent.\n                    element = element.value.slice(0, element.value.length - commonIndent);\n                }\n                if (element) {\n                    baked.push(element);\n                }\n            }\n            return baked;\n        }\n        function parsePlaceable() {\n            consumeToken(TOKEN_BRACE_OPEN, SyntaxError);\n            let selector = parseInlineExpression();\n            if (consumeToken(TOKEN_BRACE_CLOSE)) {\n                return selector;\n            }\n            if (consumeToken(TOKEN_ARROW)) {\n                let variants = parseVariants();\n                consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);\n                return {\n                    type: \"select\",\n                    selector,\n                    ...variants\n                };\n            }\n            throw new SyntaxError(\"Unclosed placeable\");\n        }\n        function parseInlineExpression() {\n            if (source[cursor] === \"{\") {\n                // It's a nested placeable.\n                return parsePlaceable();\n            }\n            if (test(RE_REFERENCE)) {\n                let [, sigil, name, attr = null] = match(RE_REFERENCE);\n                if (sigil === \"$\") {\n                    return { type: \"var\", name };\n                }\n                if (consumeToken(TOKEN_PAREN_OPEN)) {\n                    let args = parseArguments();\n                    if (sigil === \"-\") {\n                        // A parameterized term: -term(...).\n                        return { type: \"term\", name, attr, args };\n                    }\n                    if (RE_FUNCTION_NAME.test(name)) {\n                        return { type: \"func\", name, args };\n                    }\n                    throw new SyntaxError(\"Function names must be all upper-case\");\n                }\n                if (sigil === \"-\") {\n                    // A non-parameterized term: -term.\n                    return {\n                        type: \"term\",\n                        name,\n                        attr,\n                        args: []\n                    };\n                }\n                return { type: \"mesg\", name, attr };\n            }\n            return parseLiteral();\n        }\n        function parseArguments() {\n            let args = [];\n            while (true) {\n                switch (source[cursor]) {\n                    case \")\": // End of the argument list.\n                        cursor++;\n                        return args;\n                    case undefined: // EOF\n                        throw new SyntaxError(\"Unclosed argument list\");\n                }\n                args.push(parseArgument());\n                // Commas between arguments are treated as whitespace.\n                consumeToken(TOKEN_COMMA);\n            }\n        }\n        function parseArgument() {\n            let expr = parseInlineExpression();\n            if (expr.type !== \"mesg\") {\n                return expr;\n            }\n            if (consumeToken(TOKEN_COLON)) {\n                // The reference is the beginning of a named argument.\n                return {\n                    type: \"narg\",\n                    name: expr.name,\n                    value: parseLiteral()\n                };\n            }\n            // It's a regular message reference.\n            return expr;\n        }\n        function parseVariants() {\n            let variants = [];\n            let count = 0;\n            let star;\n            while (test(RE_VARIANT_START)) {\n                if (consumeChar(\"*\")) {\n                    star = count;\n                }\n                let key = parseVariantKey();\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected variant value\");\n                }\n                variants[count++] = { key, value };\n            }\n            if (count === 0) {\n                return null;\n            }\n            if (star === undefined) {\n                throw new SyntaxError(\"Expected default variant\");\n            }\n            return { variants, star };\n        }\n        function parseVariantKey() {\n            consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);\n            let key;\n            if (test(RE_NUMBER_LITERAL)) {\n                key = parseNumberLiteral();\n            }\n            else {\n                key = {\n                    type: \"str\",\n                    value: match1(RE_IDENTIFIER)\n                };\n            }\n            consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);\n            return key;\n        }\n        function parseLiteral() {\n            if (test(RE_NUMBER_LITERAL)) {\n                return parseNumberLiteral();\n            }\n            if (source[cursor] === '\"') {\n                return parseStringLiteral();\n            }\n            throw new SyntaxError(\"Invalid expression\");\n        }\n        function parseNumberLiteral() {\n            let [, value, fraction = \"\"] = match(RE_NUMBER_LITERAL);\n            let precision = fraction.length;\n            return {\n                type: \"num\",\n                value: parseFloat(value),\n                precision\n            };\n        }\n        function parseStringLiteral() {\n            consumeChar('\"', SyntaxError);\n            let value = \"\";\n            while (true) {\n                value += match1(RE_STRING_RUN);\n                if (source[cursor] === \"\\\\\") {\n                    value += parseEscapeSequence();\n                    continue;\n                }\n                if (consumeChar('\"')) {\n                    return { type: \"str\", value };\n                }\n                // We've reached an EOL of EOF.\n                throw new SyntaxError(\"Unclosed string literal\");\n            }\n        }\n        // Unescape known escape sequences.\n        function parseEscapeSequence() {\n            if (test(RE_STRING_ESCAPE)) {\n                return match1(RE_STRING_ESCAPE);\n            }\n            if (test(RE_UNICODE_ESCAPE)) {\n                let [, codepoint4, codepoint6] = match(RE_UNICODE_ESCAPE);\n                let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                return codepoint <= 0xd7ff || 0xe000 <= codepoint\n                    // It's a Unicode scalar value.\n                    ? String.fromCodePoint(codepoint)\n                    // Lonely surrogates can cause trouble when the parsing result is\n                    // saved using UTF-8. Use U+FFFD REPLACEMENT CHARACTER instead.\n                    : \"�\";\n            }\n            throw new SyntaxError(\"Unknown escape sequence\");\n        }\n        // Parse blank space. Return it if it looks like indent before a pattern\n        // line. Skip it othwerwise.\n        function parseIndent() {\n            let start = cursor;\n            consumeToken(TOKEN_BLANK);\n            // Check the first non-blank character after the indent.\n            switch (source[cursor]) {\n                case \".\":\n                case \"[\":\n                case \"*\":\n                case \"}\":\n                case undefined: // EOF\n                    // A special character. End the Pattern.\n                    return false;\n                case \"{\":\n                    // Placeables don't require indentation (in EBNF: block-placeable).\n                    // Continue the Pattern.\n                    return makeIndent(source.slice(start, cursor));\n            }\n            // If the first character on the line is not one of the special characters\n            // listed above, it's a regular text character. Check if there's at least\n            // one space of indent before it.\n            if (source[cursor - 1] === \" \") {\n                // It's an indented text character (in EBNF: indented-char). Continue\n                // the Pattern.\n                return makeIndent(source.slice(start, cursor));\n            }\n            // A not-indented text character is likely the identifier of the next\n            // message. End the Pattern.\n            return false;\n        }\n        // Trim blanks in text according to the given regex.\n        function trim(text, re) {\n            return text.replace(re, \"\");\n        }\n        // Normalize a blank block and extract the indent details.\n        function makeIndent(blank) {\n            let value = blank.replace(RE_BLANK_LINES, \"\\n\");\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let length = RE_INDENT.exec(blank)[1].length;\n            return new Indent(value, length);\n        }\n    }\n}\nclass Indent {\n    constructor(value, length) {\n        this.value = value;\n        this.length = length;\n    }\n}\n","/**\n * @module fluent\n * @overview\n *\n * `fluent` is a JavaScript implementation of Project Fluent, a localization\n * framework designed to unleash the expressive power of the natural language.\n *\n */\nexport { FluentBundle } from \"./bundle.js\";\nexport { FluentResource } from \"./resource.js\";\nexport { FluentType, FluentNumber, FluentDateTime } from \"./types.js\";\n","/*\n * Synchronously map an identifier or an array of identifiers to the best\n * `FluentBundle` instance(s).\n *\n * @param bundles - An iterable of bundles to sift through.\n * @param ids - An id or ids to map.\n */\nexport function mapBundleSync(bundles, ids) {\n    if (!Array.isArray(ids)) {\n        return getBundleForId(bundles, ids);\n    }\n    return ids.map(id => getBundleForId(bundles, id));\n}\n/*\n * Find the best `FluentBundle` with the translation for `id`.\n */\nfunction getBundleForId(bundles, id) {\n    for (const bundle of bundles) {\n        if (bundle.hasMessage(id)) {\n            return bundle;\n        }\n    }\n    return null;\n}\n","/*\n * Asynchronously map an identifier or an array of identifiers to the best\n * `FluentBundle` instance(s).\n *\n * @param bundles - An iterable of bundles to sift through.\n * @param ids - An id or ids to map.\n */\nexport async function mapBundleAsync(bundles, ids) {\n    if (!Array.isArray(ids)) {\n        for await (const bundle of bundles) {\n            if (bundle.hasMessage(ids)) {\n                return bundle;\n            }\n        }\n        return null;\n    }\n    const foundBundles = new Array(ids.length).fill(null);\n    let remainingCount = ids.length;\n    for await (const bundle of bundles) {\n        for (const [index, id] of ids.entries()) {\n            if (!foundBundles[index] && bundle.hasMessage(id)) {\n                foundBundles[index] = bundle;\n                remainingCount--;\n            }\n            // Return early when all ids have been mapped to bundles.\n            if (remainingCount === 0) {\n                return foundBundles;\n            }\n        }\n    }\n    return foundBundles;\n}\n","/*\n * @module fluent-sequence\n * @overview Manage ordered sequences of FluentBundles.\n */\nexport { mapBundleSync } from \"./map_sync.js\";\nexport { mapBundleAsync } from \"./map_async.js\";\n","/*\n * Base CachedIterable class.\n */\nexport default class CachedIterable extends Array {\n    /**\n     * Create a `CachedIterable` instance from an iterable or, if another\n     * instance of `CachedIterable` is passed, return it without any\n     * modifications.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedIterable}\n     */\n    static from(iterable) {\n        if (iterable instanceof this) {\n            return iterable;\n        }\n\n        return new this(iterable);\n    }\n}\n","import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedSyncIterable caches the elements yielded by an iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedSyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedSyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedSyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    [Symbol.iterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && last.done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n","import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedAsyncIterable caches the elements yielded by an async iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedAsyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedAsyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedAsyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.asyncIterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.asyncIterator]();\n        } else if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    /**\n     * Asynchronous iterator caching the yielded elements.\n     *\n     * Elements yielded by the original iterable will be cached and available\n     * synchronously. Returns an async generator object implementing the\n     * iterator protocol over the elements of the original (async or sync)\n     * iterable.\n     */\n    [Symbol.asyncIterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            async next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    async touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && (await last).done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n","export {default as CachedSyncIterable} from \"./cached_sync_iterable.mjs\";\nexport {default as CachedAsyncIterable} from \"./cached_async_iterable.mjs\";\n","import { FluentBundle, FluentResource } from \"@fluent/bundle\";\nimport { mapBundleSync } from \"@fluent/sequence\";\nimport { CachedSyncIterable } from \"cached-iterable\";\n\nconst internalAttributes = [\"messageid\"];\n\nfunction parsedBundles(fetchedMessages) {\n  const bundles = [];\n\n  for (let [locale, messages] of fetchedMessages) {\n    let resource = new FluentResource(messages);\n    let bundle = new FluentBundle(locale);\n\n    bundle.addResource(resource);\n    bundles.push(bundle);\n  }\n\n  return bundles;\n}\n\ncustomElements.define(\n  \"fluent-text\",\n  class extends HTMLElement {\n    constructor() {\n      super();\n\n      if (window.fluentWeb == null) {\n        window.fluentWeb = new FluentWeb();\n      }\n    }\n\n    connectedCallback() {\n      this.render();\n    }\n\n    set messages(newValue) {\n      this.buildBundles(newValue);\n      this.render();\n    }\n\n    set args(newValue) {\n      this.messageArgs = newValue;\n      this.render();\n    }\n\n    static get observedAttributes() {\n      return [\"messageId\"];\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"messageId\" && oldValue !== newValue) {\n        this.render();\n      }\n    }\n\n    buildBundles(messages) {\n      let bundles = parsedBundles(messages);\n      window.fluentWeb.setBundles(bundles);\n    }\n\n    render() {\n      const message = window.fluentWeb.getMessage({\n        messageId: this.getAttribute(\"messageId\"),\n        args: this.messageArgs,\n      });\n\n      if (message) {\n        if (message.value && message.value !== \"{???}\") {\n          const template = document.createElement(\"template\");\n          template.innerHTML = message.value;\n          this.innerHTML = \"\";\n          Array.from(template.content.childNodes).forEach((node) => {\n            this.appendChild(node);\n          });\n        }\n      }\n    }\n  }\n);\n\ncustomElements.define(\n  \"fluent-element\",\n  class extends HTMLElement {\n    constructor() {\n      super();\n\n      if (window.fluentWeb == null) {\n        window.fluentWeb = new FluentWeb();\n      }\n    }\n\n    connectedCallback() {\n      this.render();\n    }\n\n    set messages(newValue) {\n      this.buildBundles(newValue);\n      this.render();\n    }\n\n    set args(newValue) {\n      this.messageArgs = newValue;\n      this.render();\n    }\n\n    static get observedAttributes() {\n      return [\"messageId\"];\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"messageId\" && oldValue !== newValue) {\n        this.render();\n      }\n    }\n\n    buildBundles(messages) {\n      let bundles = parsedBundles(messages);\n      window.fluentWeb.setBundles(bundles);\n    }\n\n    render() {\n      const message = window.fluentWeb.getMessage({\n        messageId: this.getAttribute(\"messageId\"),\n        args: this.messageArgs,\n      });\n\n      if (message) {\n        if (this.firstElementChild) {\n          Object.entries(message.attributes).forEach(([key, val]) => {\n            this.firstElementChild.setAttribute(key, val);\n          });\n\n          if (message.value && message.value !== \"{???}\") {\n            const template = document.createElement(\"template\");\n            template.innerHTML = message.value;\n            this.firstElementChild.innerHTML = \"\";\n            Array.from(template.content.childNodes).forEach((node) => {\n              this.firstElementChild.appendChild(node);\n            });\n          }\n\n          this.getAttributeNames().forEach((name) => {\n            if (!internalAttributes.includes(name)) {\n              this.firstElementChild.setAttribute(\n                name,\n                this.getAttribute(name)\n              );\n            }\n          });\n        }\n      }\n    }\n  }\n);\n\nclass FluentWeb {\n  setBundles(bundles) {\n    this.bundles = CachedSyncIterable.from(bundles);\n  }\n\n  getMessage({ messageId, args }) {\n    if (this.bundles) {\n      const bundle = mapBundleSync(this.bundles, messageId);\n\n      if (bundle) {\n        const message = bundle.getMessage(messageId);\n\n        if (message) {\n          let errors = [];\n          const value = bundle.formatPattern(message.value, args, errors);\n\n          return { value, attributes: message.attributes };\n        }\n      }\n    }\n\n    return null;\n  }\n}\n"]}